<!DOCTYPE html>
<html lang="en-us" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>개인적으로 사용하는 emacs 설정 모음 | 전파고양이</title>
<meta name="keywords" content="">
<meta name="description" content="Index
  Related:
  emacs main inbox  emacs-my-package emacs-lisp-배워보기 emacs-documentation  emacs-yasnippet Snippet collections can be stored in plain text files. They are arranged by sub-directories naming snippet tables. These mostly name Emacs major mode names. 기본적으로 Emacs major Mode의 네임으로 subdir을 만들어서 관리한다.
Triggering Expansion   link
  when yas-minor-mode is active 일 때 triggering key를 누르면 확장 된다.
  Writting Snippet emacs-my-package 내가 사용하는 package를 모아서 정리">
<meta name="author" content="VERITAS">
<link rel="canonical" href="/post/emacs/emacs/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.96771a12b249af1ff464eabdaa85d1a5268a4379a9f2da62cfd409656ff0233b.css" integrity="sha256-lncaErJJrx/0ZOq9qoXRpSaKQ3mp8tpiz9QJZW/wIzs=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="개인적으로 사용하는 emacs 설정 모음" />
<meta property="og:description" content="Index
  Related:
  emacs main inbox  emacs-my-package emacs-lisp-배워보기 emacs-documentation  emacs-yasnippet Snippet collections can be stored in plain text files. They are arranged by sub-directories naming snippet tables. These mostly name Emacs major mode names. 기본적으로 Emacs major Mode의 네임으로 subdir을 만들어서 관리한다.
Triggering Expansion   link
  when yas-minor-mode is active 일 때 triggering key를 누르면 확장 된다.
  Writting Snippet emacs-my-package 내가 사용하는 package를 모아서 정리" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/emacs/emacs/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2020-03-01T00:00:00+09:00" />
<meta property="article:modified_time" content="2020-03-01T00:00:00+09:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="개인적으로 사용하는 emacs 설정 모음"/>
<meta name="twitter:description" content="Index
  Related:
  emacs main inbox  emacs-my-package emacs-lisp-배워보기 emacs-documentation  emacs-yasnippet Snippet collections can be stored in plain text files. They are arranged by sub-directories naming snippet tables. These mostly name Emacs major mode names. 기본적으로 Emacs major Mode의 네임으로 subdir을 만들어서 관리한다.
Triggering Expansion   link
  when yas-minor-mode is active 일 때 triggering key를 누르면 확장 된다.
  Writting Snippet emacs-my-package 내가 사용하는 package를 모아서 정리"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Programming Note",
      "item": "/post/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "개인적으로 사용하는 emacs 설정 모음",
      "item": "/post/emacs/emacs/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "개인적으로 사용하는 emacs 설정 모음",
  "name": "개인적으로 사용하는 emacs 설정 모음",
  "description": "Index\n  Related:\n  emacs main inbox  emacs-my-package emacs-lisp-배워보기 emacs-documentation  emacs-yasnippet Snippet collections can be stored in plain text files. They are arranged by sub-directories naming snippet tables. These mostly name Emacs major mode names. 기본적으로 Emacs major Mode의 네임으로 subdir을 만들어서 관리한다.\nTriggering Expansion   link\n  when yas-minor-mode is active 일 때 triggering key를 누르면 확장 된다.\n  Writting Snippet emacs-my-package 내가 사용하는 package를 모아서 정리",
  "keywords": [
    
  ],
  "articleBody": "  Index\n  Related:\n  emacs main inbox  emacs-my-package emacs-lisp-배워보기 emacs-documentation  emacs-yasnippet Snippet collections can be stored in plain text files. They are arranged by sub-directories naming snippet tables. These mostly name Emacs major mode names. 기본적으로 Emacs major Mode의 네임으로 subdir을 만들어서 관리한다.\nTriggering Expansion   link\n  when yas-minor-mode is active 일 때 triggering key를 누르면 확장 된다.\n  Writting Snippet emacs-my-package 내가 사용하는 package를 모아서 정리\n orgmode tide hydra company-mode yasnippet auto-complete hook 개념 이해하기  Code Formatting 코드 포맷을 하기 위해서 다음과 같은 것을 할 수 있을 것 같다.\n편집 스타일   바닐라 이맥스\n  evil mode\n  compasable.el\n  emacs my configuration 이맥스를 자주 사용하는데 설정을 어떻게 바꿨는지 무슨 기능들이 있었는지 잘 모르겠어서 여기에 히스토리를 정리해놓으려고 한다. 이렇게 하면 앞으로 잘 쓸 수 있지 않을까?\norgmode orgmode    설명 keybind      org-narrow-subtree C-x n n 내가 원하는 글 쓰는 장소로 집중할 수 있다.   org-next-visible-heading C-c C-n 다음 heading으로 이동   org-forward-heading-same-level C-c C-f 글 쓰는 도중에 사용하면 해당헤드로 이동 가능   org-backward-heading-same-level C-c C-b 글 쓰는 도중에 사용하면 해당 헤드로 이동 가능   org-clock-report C-c C-x C-r    org-clock-in C-c C-x C-i    org-clock-out C-c C-x C-o     orgmode code navigation    설명 keybind      jump into definition M-,    Move back to defitnion M-.    해당 코드에서 바인드된것들 요약해서 캡쳐하기      file navigation    설명 keybind      treemacs-toggle C-x t t treemacs toggle   next-navigation n next   previous-navigation p previous   edit-work-space C-c C-w e workspace edit   switch-work-space C-c C-w s switch work space   open no split o o open no split   open vertical split o v open vertical spli   open-horizontally o h open horizontally   create-file c f    create-dir c d    open-ace-? o a (a, h, v) 선택 해서 오픈하기    MacOS에서 org-protocol 사용하기 Platus라는 앱을 발견 emacs-documentation 14.22 Visual Line Mode Another alternative to ordinary line continuation is to use word wrap. Here, each long logical line is divided into two or more screen lines, like in ordinary line continuation. However, Emacs attempts to wrap the line at word boundaries near the right window edge. (If the line’s direction is right-to-left, it is wrapped at the left window edge instead.) This makes the text easier to read, as wrapping does not occur in the middle of words.\n일반적인 라인 이어짐(line continuation)에 대한 대한으로는 word wrap을 상요하는 것이다. 여기에 긴 논리적 라인이 2개 또는 더 많은 스크린의 줄에서\nWord wrap is enabled by Visual Line mode, an optional minor mode. To turn on Visual Line mode in the current buffer, type M-x visual-line-mode; repeating this command turns it off. You can also turn on Visual Line mode using the menu bar: in the Options menu, select the ‘Line Wrapping in this Buffer’ submenu, followed by the ‘Word Wrap (Visual Line mode)’ menu item. While Visual Line mode is enabled, the mode line shows the string ‘wrap’ in the mode display. The command M-x global-visual-line-mode toggles Visual Line mode in all buffers.\nIn Visual Line mode, some editing commands work on screen lines instead of logical lines: C-a (beginning-of-visual-line) moves to the beginning of the screen line, C-e (end-of-visual-line) moves to the end of the screen line, and C-k (kill-visual-line) kills text to the end of the screen line.\nTo move by logical lines, use the commands M-x next-logical-line and M-x previous-logical-line. These move point to the next logical line and the previous logical line respectively, regardless of whether Visual Line mode is enabled. If you use these commands frequently, it may be convenient to assign key bindings to them. See Init Rebinding.\nBy default, word-wrapped lines do not display fringe indicators. Visual Line mode is often used to edit files that contain many long logical lines, so having a fringe indicator for each wrapped line would be visually distracting. You can change this by customizing the variable visual-line-fringe-indicators\n",
  "wordCount" : "605",
  "inLanguage": "en-us",
  "datePublished": "2020-03-01T00:00:00+09:00",
  "dateModified": "2020-03-01T00:00:00+09:00",
  "author":[{
    "@type": "Person",
    "name": "VERITAS"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/emacs/emacs/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "전파고양이",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="전파고양이 (Alt + H)">전파고양이</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      개인적으로 사용하는 emacs 설정 모음
    </h1>
    <div class="post-meta"><span title='2020-03-01 00:00:00 +0900 KST'>March 01, 2020</span>&nbsp;·&nbsp;VERITAS

</div>
  </header> 
  <div class="post-content"><ul>
<li>
<p><a href="index">Index</a></p>
</li>
<li>
<p>Related:</p>
</li>
</ul>
<h2 id="emacs-main-inbox">emacs main inbox<a hidden class="anchor" aria-hidden="true" href="#emacs-main-inbox">#</a></h2>
<ul>
<li><a href="emacs-my-package">emacs-my-package</a></li>
<li><a href="emacslisp-%EB%B0%B0%EC%9B%8C%EB%B3%B4%EA%B8%B0">emacs-lisp-배워보기</a></li>
<li><a href="emacs-documentation">emacs-documentation</a></li>
</ul>
<h3 id="emacs-yasnippet">emacs-yasnippet<a hidden class="anchor" aria-hidden="true" href="#emacs-yasnippet">#</a></h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Snippet collections can be stored in plain text files. They are arranged by sub-directories naming snippet tables. These mostly name Emacs major mode names.
</code></pre></div><p>기본적으로 Emacs major Mode의 네임으로 subdir을 만들어서 관리한다.</p>
<h4 id="triggering-expansion">Triggering Expansion<a hidden class="anchor" aria-hidden="true" href="#triggering-expansion">#</a></h4>
<ul>
<li>
<p><a href="http://joaotavora.github.io/yasnippet/snippet-expansion.html">link</a></p>
</li>
<li>
<p>when yas-minor-mode is active 일 때 triggering key를 누르면 확장 된다.</p>
</li>
</ul>
<h4 id="writting-snippet">Writting Snippet<a hidden class="anchor" aria-hidden="true" href="#writting-snippet">#</a></h4>
<h3 id="emacs-my-package">emacs-my-package<a hidden class="anchor" aria-hidden="true" href="#emacs-my-package">#</a></h3>
<p>내가 사용하는 package를 모아서 정리</p>
<ul>
<li>orgmode</li>
<li>tide</li>
<li>hydra</li>
<li>company-mode</li>
<li>yasnippet</li>
<li>auto-complete</li>
<li>hook 개념 이해하기</li>
</ul>
<h4 id="code-formatting">Code Formatting<a hidden class="anchor" aria-hidden="true" href="#code-formatting">#</a></h4>
<p>코드 포맷을 하기 위해서 다음과 같은 것을 할 수 있을 것 같다.</p>
<h4 id="편집-스타일">편집 스타일<a hidden class="anchor" aria-hidden="true" href="#편집-스타일">#</a></h4>
<ul>
<li>
<p>바닐라 이맥스</p>
</li>
<li>
<p>evil mode</p>
</li>
<li>
<p>compasable.el</p>
</li>
</ul>
<h3 id="emacs-my-configuration">emacs my configuration<a hidden class="anchor" aria-hidden="true" href="#emacs-my-configuration">#</a></h3>
<p>이맥스를 자주 사용하는데 설정을 어떻게 바꿨는지 무슨 기능들이 있었는지 잘 모르겠어서 여기에 히스토리를 정리해놓으려고 한다. 이렇게 하면 앞으로 잘 쓸 수 있지 않을까?</p>
<h4 id="orgmode">orgmode<a hidden class="anchor" aria-hidden="true" href="#orgmode">#</a></h4>
<h4 id="orgmode">orgmode<a hidden class="anchor" aria-hidden="true" href="#orgmode">#</a></h4>
<table>
<thead>
<tr>
<th>설명</th>
<th>keybind</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>org-narrow-subtree</td>
<td>C-x n n</td>
<td>내가 원하는 글 쓰는 장소로 집중할 수 있다.</td>
</tr>
<tr>
<td>org-next-visible-heading</td>
<td>C-c C-n</td>
<td>다음 heading으로 이동</td>
</tr>
<tr>
<td>org-forward-heading-same-level</td>
<td>C-c C-f</td>
<td>글 쓰는 도중에 사용하면 해당헤드로 이동 가능</td>
</tr>
<tr>
<td>org-backward-heading-same-level</td>
<td>C-c C-b</td>
<td>글 쓰는 도중에 사용하면 해당 헤드로 이동 가능</td>
</tr>
<tr>
<td>org-clock-report</td>
<td>C-c C-x C-r</td>
<td></td>
</tr>
<tr>
<td>org-clock-in</td>
<td>C-c C-x C-i</td>
<td></td>
</tr>
<tr>
<td>org-clock-out</td>
<td>C-c C-x C-o</td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="orgmode">orgmode<a hidden class="anchor" aria-hidden="true" href="#orgmode">#</a></h4>
<h4 id="code-navigation">code navigation<a hidden class="anchor" aria-hidden="true" href="#code-navigation">#</a></h4>
<table>
<thead>
<tr>
<th>설명</th>
<th>keybind</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>jump into definition</td>
<td>M-,</td>
<td></td>
</tr>
<tr>
<td>Move back to defitnion</td>
<td>M-.</td>
<td></td>
</tr>
<tr>
<td>해당 코드에서 바인드된것들 요약해서 캡쳐하기</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="file-navigation">file navigation<a hidden class="anchor" aria-hidden="true" href="#file-navigation">#</a></h4>
<table>
<thead>
<tr>
<th>설명</th>
<th>keybind</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>treemacs-toggle</td>
<td>C-x t t</td>
<td>treemacs toggle</td>
</tr>
<tr>
<td>next-navigation</td>
<td>n</td>
<td>next</td>
</tr>
<tr>
<td>previous-navigation</td>
<td>p</td>
<td>previous</td>
</tr>
<tr>
<td>edit-work-space</td>
<td>C-c C-w e</td>
<td>workspace edit</td>
</tr>
<tr>
<td>switch-work-space</td>
<td>C-c C-w s</td>
<td>switch work space</td>
</tr>
<tr>
<td>open no split</td>
<td>o o</td>
<td>open no split</td>
</tr>
<tr>
<td>open vertical split</td>
<td>o v</td>
<td>open vertical spli</td>
</tr>
<tr>
<td>open-horizontally</td>
<td>o h</td>
<td>open horizontally</td>
</tr>
<tr>
<td>create-file</td>
<td>c f</td>
<td></td>
</tr>
<tr>
<td>create-dir</td>
<td>c d</td>
<td></td>
</tr>
<tr>
<td>open-ace-?</td>
<td>o a (a, h, v)</td>
<td>선택 해서 오픈하기</td>
</tr>
</tbody>
</table>
<h3 id="macos에서-org-protocol-사용하기">MacOS에서 org-protocol 사용하기<a hidden class="anchor" aria-hidden="true" href="#macos에서-org-protocol-사용하기">#</a></h3>
<h4 id="platus라는-앱을-발견">Platus라는 앱을 발견<a hidden class="anchor" aria-hidden="true" href="#platus라는-앱을-발견">#</a></h4>
<h3 id="emacs-documentation">emacs-documentation<a hidden class="anchor" aria-hidden="true" href="#emacs-documentation">#</a></h3>
<h4 id="14-dot-22-visual-line-mode">14.22 Visual Line Mode<a hidden class="anchor" aria-hidden="true" href="#14-dot-22-visual-line-mode">#</a></h4>
<p>Another alternative to ordinary line continuation is to use word wrap. Here, each long logical line is divided into two or more screen lines, like in ordinary line continuation. However, Emacs attempts to wrap the line at word boundaries near the right window edge. (If the line&rsquo;s direction is right-to-left, it is wrapped at the left window edge instead.) This makes the text easier to read, as wrapping does not occur in the middle of words.</p>
<p>일반적인 라인 이어짐(line continuation)에 대한 대한으로는 word wrap을 상요하는 것이다. 여기에 긴 논리적 라인이 2개 또는 더 많은 스크린의 줄에서</p>
<p>Word wrap is enabled by Visual Line mode, an optional minor mode. To turn on Visual Line mode in the current buffer, type M-x visual-line-mode; repeating this command turns it off. You can also turn on Visual Line mode using the menu bar: in the Options menu, select the ‘Line Wrapping in this Buffer’ submenu, followed by the ‘Word Wrap (Visual Line mode)’ menu item. While Visual Line mode is enabled, the mode line shows the string ‘wrap’ in the mode display. The command M-x global-visual-line-mode toggles Visual Line mode in all buffers.</p>
<p>In Visual Line mode, some editing commands work on screen lines instead of logical lines: C-a (beginning-of-visual-line) moves to the beginning of the screen line, C-e (end-of-visual-line) moves to the end of the screen line, and C-k (kill-visual-line) kills text to the end of the screen line.</p>
<p>To move by logical lines, use the commands M-x next-logical-line and M-x previous-logical-line. These move point to the next logical line and the previous logical line respectively, regardless of whether Visual Line mode is enabled. If you use these commands frequently, it may be convenient to assign key bindings to them. See Init Rebinding.</p>
<p>By default, word-wrapped lines do not display fringe indicators. Visual Line mode is often used to edit files that contain many long logical lines, so having a fringe indicator for each wrapped line would be visually distracting. You can change this by customizing the variable visual-line-fringe-indicators</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2022 <a href="/">전파고양이</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
