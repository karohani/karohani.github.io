[{"content":"출력하기 print(\u0026#34;이렇게 출력합니다\u0026#34;) (message \u0026#34;이렇게 출력합니다\u0026#34;) 이렇게 출력합니다 emacslisp-배워보기 표현식 이해하기 리스트 형태의 표현식이 계산될 때 좌에서 우로 계산 되며 첫번째 원소는 함수의 정의로 나머지 원소는 인자들로 계산된 후 함수를 호출하게 된다. 호출된 함수가 리턴하는 값을 그 표현식의 값(value)라고 부른다.\n(message \u0026#34;hello workd\u0026#34;) hello workd (message \u0026#34;hello: %d\u0026#34; (+ 1 2)) hello: 3 메시지는 \u0026ldquo;hello: %\u0026ldquo;와 3을 argument로 받아 실핵된다.\n심벌 이해하기 자신의 그대로 값으로 계산되지 않은 message + 를 심벌이라고 부른다. 이들은 쓰여진 위치에 따라 할당된 함수나 값으로 계산된다.\n(message \u0026#34;withd %d\u0026#34; fill-column) withd 70 심벌은 리스트 형태의 표현식에 첫 번째 원소의 위치로 쓰였을 때 함수로 계산된다. 그 외의는 전부 값으로 계산된다.\n\u0026#39;(message \u0026#34;width %d\u0026#34; fill-column) ; (message \u0026#34;width %d\u0026#34; fill-column) message width %d fill-column 위와 \u0026lsquo;가 붙으면 리스트 그 자체가 리턴된다. \u0026lsquo;를 리스트의 형태의 표현식에 적용한다는 것은 각 원소에 \u0026lsquo;를 적용하고 그 심벌들을 다시 리스트로 만드는 것을 의미한다.\n리스트 cons (cons 1 2) (1 . 2) cdr (car (cons 1 2)) 1 car (cdr (cons 1 (cons 3 4))) (3 . 4) cons 구조에 대한 설명 위와 같은 cons의 구조는 linked list와 동일한 구조의 형태를 가지게 된다. cons의 오른쪽 박스가 다른 cons의 구조를 가리키게 되면서 여러개의 cons를 묶을 수 있게 된다.\n(cons 1 (cons 2 (cons 3 nil ))) 1 2 3 ()는 nil을 표현한다. 이것을 특별히 nil로 동일하게 나타낸다.\n(cons 1 (cons 2 nil)) (list 1 2 3) 1 2 3 ","permalink":"/post/emacs/emacs-lisp-datatype/","summary":"출력하기 print(\u0026#34;이렇게 출력합니다\u0026#34;) (message \u0026#34;이렇게 출력합니다\u0026#34;) 이렇게 출력합니다 emacslisp-배워보기 표현식 이해하기 리스트 형태의 표현식이 계산될 때 좌에서 우로 계산 되며 첫번째 원소는 함수의 정의로 나머지 원소는 인자들로 계산된 후 함수를 호출하게 된다. 호출된 함수가 리턴하는 값을 그 표현식의 값(value)라고 부른다.\n(message \u0026#34;hello workd\u0026#34;) hello workd (message \u0026#34;hello: %d\u0026#34; (+ 1 2)) hello: 3 메시지는 \u0026ldquo;hello: %\u0026ldquo;와 3을 argument로 받아 실핵된다.\n심벌 이해하기 자신의 그대로 값으로 계산되지 않은 message + 를 심벌이라고 부른다.","title":"Emacs-lisp 자료형"},{"content":"(if COND THEN ELSE \u0026hellip;)\nCOND의 결과가 nil이 아니면 THEN 표현식을 계산후에 리턴. 아니면 \u0026hellip;을 계산한 후에 마지막 표현식을 리턴한다.\n(message \u0026#34;hello %s\u0026#34; (if (= 1 2) \u0026#34;hello\u0026#34; \u0026#34;world\u0026#34;)) hello world ","permalink":"/post/emacs/emacs-lisp-condition/","summary":"(if COND THEN ELSE \u0026hellip;)\nCOND의 결과가 nil이 아니면 THEN 표현식을 계산후에 리턴. 아니면 \u0026hellip;을 계산한 후에 마지막 표현식을 리턴한다.\n(message \u0026#34;hello %s\u0026#34; (if (= 1 2) \u0026#34;hello\u0026#34; \u0026#34;world\u0026#34;)) hello world ","title":"Emacs-lisp 조건문"},{"content":"Hugo DONE Hugo Directory 구조 설명 The following is a high-level overview of each of the directories with links to each of their respective sections within the Hugo docs.\narchetypes\nYou can create new content files in Hugo using the hugo new command. By default, Hugo will create new content files with at least date, title (inferred from the filename), and draft = true. This saves time and promotes consistency for sites using multiple content types. You can create your own archetypes with custom preconfigured front matter fields as well. assets\nStores all the files which need be processed by Hugo Pipes. Only the files whose .Permalink or .RelPermalink are used will be published to the public directory. Note: assets directory is not created by default. config\nHugo ships with a large number of configuration directives. The config directory is where those directives are stored as JSON, YAML, or TOML files. Every root setting object can stand as its own file and structured by environments. Projects with minimal settings and no need for environment awareness can use a single config.toml file at its root. Many sites may need little to no configuration, but Hugo ships with a large number of configuration directives for more granular directions on how you want Hugo to build your website. Note: config directory is not created by default. content\nAll content for your website will live inside this directory. Each top-level folder in Hugo is considered a content section. For example, if your site has three main sections—blog, articles, and tutorials—you will have three directories at content/blog, content/articles, and content/tutorials. Hugo uses sections to assign default content types.\n모든 컨텐츠는 이 곳에 저장됩니다. 각 최고 레벨의 폴더는 휴고에서 Content-Section으로 관리됩니다. 예를 들면 당신이 3개의 메인 섹션이 있다면 여기에 폴더를 3개 만들면 됩니다.\ndata\nThis directory is used to store configuration files that can be used by Hugo when generating your website. You can write these files in YAML, JSON, or TOML format. In addition to the files you add to this folder, you can also create data templates that pull from dynamic content. layouts\nStores templates in the form of .html files that specify how views of your content will be rendered into a static website. Templates include list pages, your homepage, taxonomy templates, partials, single page templates, and more. static\nStores all the static content: images, CSS, JavaScript, etc. When Hugo builds your site, all assets inside your static directory are copied over as-is. A good example of using the static folder is for verifying site ownership on Google Search Console, where you want Hugo to copy over a complete HTML file without modifying its content. From Hugo 0.31 you can have multiple static directories. resources\nCaches some files to speed up generation. Can be also used by template authors to distribute built Sass files, so you don’t have to have the preprocessor installed. Note: resources directory is not created by default. ","permalink":"/etc/hugo/","summary":"Hugo DONE Hugo Directory 구조 설명 The following is a high-level overview of each of the directories with links to each of their respective sections within the Hugo docs.\narchetypes\nYou can create new content files in Hugo using the hugo new command. By default, Hugo will create new content files with at least date, title (inferred from the filename), and draft = true. This saves time and promotes consistency for sites using multiple content types.","title":"Hugo"},{"content":"subtype이란 무엇인가? F가 G의 서브타입이라면 G가 쓰일 자리에 F가 쓰여도 된다.\nIn programming language theory, subtyping (also subtype polymorphism or inclusion polymorphism) is a form of type polymorphism in which a subtype is a datatype that is related to another datatype (the supertype) by some notion of substitutability, meaning that program elements, typically subroutines or functions, written to operate on elements of the supertype can also operate on elements of the subtype. 프로그래밍 이론에서 subtyping(subtype polymorphism, inclusion polymorphism이라고 불리는) 은 타입다형성의 한 형태이다. 상위타입으로 작성된 서브루틴이나 함수들이 하위타입을 대입해도 동일하게 하는 것을 서브타입이라고 부른다. 그냥 하나의 타입만 있을 때가 아닌 kind를 다룰 때 이 서브타입에 어떤 규칙들을 지켜야 하는지\nhttps://softwareengineering.stackexchange.com/questions/255878/correct-terminology-in-type-theory-types-type-constructors-kinds-sorts-and-va\n값(value) 타입(type) 종류(kinds) 타입생성자 타입파라미터 covariant, countra-variant https://typelevel.org/blog/2016/02/04/variance-and-functors.html\n우리가 Generic을 만들 때 다음과 같은 개념들을 사용한다. T\u0026rsquo;이 T의 서브타입일 때 다음과 같이 정의된다.\n키워드 의미 표기 covariant F[T\u0026rsquo;] 는 F[T]의 서브타입이다 [+T] countravariant F[T] 는 F[T\u0026rsquo;]의 서브타입이다. [-T] invariant F[T] 와 F[T\u0026rsquo;]는 어떠한 관계도 없다 [T] 변성과 반변성의 개념에 대해서 이해해보자.\n함수의 인자는 반공변적이고 리턴타입은 공변적이어야 한다 . https://stackoverflow.com/questions/41098105/subtyping-between-function-types\n","permalink":"/post/emacs/pis-19-typeparameter/","summary":"subtype이란 무엇인가? F가 G의 서브타입이라면 G가 쓰일 자리에 F가 쓰여도 된다.\nIn programming language theory, subtyping (also subtype polymorphism or inclusion polymorphism) is a form of type polymorphism in which a subtype is a datatype that is related to another datatype (the supertype) by some notion of substitutability, meaning that program elements, typically subroutines or functions, written to operate on elements of the supertype can also operate on elements of the subtype.","title":"19장 타입파라미터"},{"content":"pyenv 설치 brew install pyenv virtualenv 사용하기 가상환경 생성하기 virtualenv {환경이름} 위의 경로를 생성하면 환경이름으로 된 폴더가 만들어짐 $ virtualenv venv 활성화 시키기 source {환경이름}/bin/activate를 입력하면 shell의 모양이 다음과 같이 바뀜\n(환경이름) $ 내가 사용하는 모듈을 저장하기 pip freeze \u0026gt; requirements.txt\n내가 사용하는 모듈 설치하기 pip install -r requirements.txt\nvirtualEnvWrapper 설정하기 virutalenv만 사용하면 매번 source를 통해서 가상환경에 진입해야 한다.\npip install virtualenvwrapper # ~/.zsrc에 아래를 등록 export WORKON_HOME=~/.virtualenvs export VIRTUALENVWRAPPER_PYTHON=\u0026#34;$(which python3)\u0026#34; # Usage of python3 source /Users/veritas/.pyenv/shims/virtualenvwrapper.sh ","permalink":"/post/python/python-environment/","summary":"pyenv 설치 brew install pyenv virtualenv 사용하기 가상환경 생성하기 virtualenv {환경이름} 위의 경로를 생성하면 환경이름으로 된 폴더가 만들어짐 $ virtualenv venv 활성화 시키기 source {환경이름}/bin/activate를 입력하면 shell의 모양이 다음과 같이 바뀜\n(환경이름) $ 내가 사용하는 모듈을 저장하기 pip freeze \u0026gt; requirements.txt\n내가 사용하는 모듈 설치하기 pip install -r requirements.txt\nvirtualEnvWrapper 설정하기 virutalenv만 사용하면 매번 source를 통해서 가상환경에 진입해야 한다.\npip install virtualenvwrapper # ~/.zsrc에 아래를 등록 export WORKON_HOME=~/.virtualenvs export VIRTUALENVWRAPPER_PYTHON=\u0026#34;$(which python3)\u0026#34; # Usage of python3 source /Users/veritas/.","title":"python virtualenv 환경정리"},{"content":" Index\nRelated:\nemacs main inbox emacs-my-package emacs-lisp-배워보기 emacs-documentation emacs-yasnippet Snippet collections can be stored in plain text files. They are arranged by sub-directories naming snippet tables. These mostly name Emacs major mode names. 기본적으로 Emacs major Mode의 네임으로 subdir을 만들어서 관리한다.\nTriggering Expansion link\nwhen yas-minor-mode is active 일 때 triggering key를 누르면 확장 된다.\nWritting Snippet emacs-my-package 내가 사용하는 package를 모아서 정리\norgmode tide hydra company-mode yasnippet auto-complete hook 개념 이해하기 Code Formatting 코드 포맷을 하기 위해서 다음과 같은 것을 할 수 있을 것 같다.\n편집 스타일 바닐라 이맥스\nevil mode\ncompasable.el\nemacs my configuration 이맥스를 자주 사용하는데 설정을 어떻게 바꿨는지 무슨 기능들이 있었는지 잘 모르겠어서 여기에 히스토리를 정리해놓으려고 한다. 이렇게 하면 앞으로 잘 쓸 수 있지 않을까?\norgmode orgmode 설명 keybind org-narrow-subtree C-x n n 내가 원하는 글 쓰는 장소로 집중할 수 있다. org-next-visible-heading C-c C-n 다음 heading으로 이동 org-forward-heading-same-level C-c C-f 글 쓰는 도중에 사용하면 해당헤드로 이동 가능 org-backward-heading-same-level C-c C-b 글 쓰는 도중에 사용하면 해당 헤드로 이동 가능 org-clock-report C-c C-x C-r org-clock-in C-c C-x C-i org-clock-out C-c C-x C-o orgmode code navigation 설명 keybind jump into definition M-, Move back to defitnion M-. 해당 코드에서 바인드된것들 요약해서 캡쳐하기 file navigation 설명 keybind treemacs-toggle C-x t t treemacs toggle next-navigation n next previous-navigation p previous edit-work-space C-c C-w e workspace edit switch-work-space C-c C-w s switch work space open no split o o open no split open vertical split o v open vertical spli open-horizontally o h open horizontally create-file c f create-dir c d open-ace-? o a (a, h, v) 선택 해서 오픈하기 MacOS에서 org-protocol 사용하기 Platus라는 앱을 발견 emacs-documentation 14.22 Visual Line Mode Another alternative to ordinary line continuation is to use word wrap. Here, each long logical line is divided into two or more screen lines, like in ordinary line continuation. However, Emacs attempts to wrap the line at word boundaries near the right window edge. (If the line\u0026rsquo;s direction is right-to-left, it is wrapped at the left window edge instead.) This makes the text easier to read, as wrapping does not occur in the middle of words.\n일반적인 라인 이어짐(line continuation)에 대한 대한으로는 word wrap을 상요하는 것이다. 여기에 긴 논리적 라인이 2개 또는 더 많은 스크린의 줄에서\nWord wrap is enabled by Visual Line mode, an optional minor mode. To turn on Visual Line mode in the current buffer, type M-x visual-line-mode; repeating this command turns it off. You can also turn on Visual Line mode using the menu bar: in the Options menu, select the ‘Line Wrapping in this Buffer’ submenu, followed by the ‘Word Wrap (Visual Line mode)’ menu item. While Visual Line mode is enabled, the mode line shows the string ‘wrap’ in the mode display. The command M-x global-visual-line-mode toggles Visual Line mode in all buffers.\nIn Visual Line mode, some editing commands work on screen lines instead of logical lines: C-a (beginning-of-visual-line) moves to the beginning of the screen line, C-e (end-of-visual-line) moves to the end of the screen line, and C-k (kill-visual-line) kills text to the end of the screen line.\nTo move by logical lines, use the commands M-x next-logical-line and M-x previous-logical-line. These move point to the next logical line and the previous logical line respectively, regardless of whether Visual Line mode is enabled. If you use these commands frequently, it may be convenient to assign key bindings to them. See Init Rebinding.\nBy default, word-wrapped lines do not display fringe indicators. Visual Line mode is often used to edit files that contain many long logical lines, so having a fringe indicator for each wrapped line would be visually distracting. You can change this by customizing the variable visual-line-fringe-indicators\n","permalink":"/post/emacs/emacs/","summary":"Index\nRelated:\nemacs main inbox emacs-my-package emacs-lisp-배워보기 emacs-documentation emacs-yasnippet Snippet collections can be stored in plain text files. They are arranged by sub-directories naming snippet tables. These mostly name Emacs major mode names. 기본적으로 Emacs major Mode의 네임으로 subdir을 만들어서 관리한다.\nTriggering Expansion link\nwhen yas-minor-mode is active 일 때 triggering key를 누르면 확장 된다.\nWritting Snippet emacs-my-package 내가 사용하는 package를 모아서 정리\norgmode tide hydra company-mode yasnippet auto-complete hook 개념 이해하기 Code Formatting 코드 포맷을 하기 위해서 다음과 같은 것을 할 수 있을 것 같다.","title":"개인적으로 사용하는 emacs 설정 모음"},{"content":"Proxy, ProxyPattern, DecoratorPattern Decorator Pattern 다른 언어와의 차이점\n자바의 함수는 1급 객체가 아니다.\nExample1 Input Stream 자바에서 Decorator패턴을 구현하기 위해서는 결국 Proxy의 형태로 구현할 수 밖에 없다. 자바는 함수가 1급 객체가 아니기 때문이다.\nFigure 1: BufferedInputStream 예제\n핵심 기능과 부가기능을 분리하는 여러가지 방법들 ","permalink":"/post/java/toby-spring-chapter-6/","summary":"Proxy, ProxyPattern, DecoratorPattern Decorator Pattern 다른 언어와의 차이점\n자바의 함수는 1급 객체가 아니다.\nExample1 Input Stream 자바에서 Decorator패턴을 구현하기 위해서는 결국 Proxy의 형태로 구현할 수 밖에 없다. 자바는 함수가 1급 객체가 아니기 때문이다.\nFigure 1: BufferedInputStream 예제\n핵심 기능과 부가기능을 분리하는 여러가지 방법들 ","title":"6장 AOP"},{"content":" java-junit link 용어정리 JUnit 기본 단언문 특징 단언문 Hamcrest 대표적인 Matchers Index\nRelated:\njava-junit sitename test\nlink github-team-junit 용어정리 test context 테스트의 정의 반복적으로 수행되고 동일한 결과를 얻어야 함 테스트케이스에서 사용하는 인스턴스 파일이나 네트워크 등의 자원을 만들어서 지정 데이터베이스 연동 JUnit 기본 단언문 assertEqual: 두개의 값이 같은지 비교 assertSame: 두 개의 객체가 정말 동일한 객체인지 확인 assertTrue: 예상 값의 참 거짓을 판별 asserNull: 대상 값이 null이면 참이 됨 fail 특징 fixture @BeforeClass @AfterClass @Before @After 테스트 종류 시간 제한 테스트 @Test(timeout=1000) 테스트 무시 @Ignore 배열지원 @RunWith JUnit Test 클래스를 실행하기 위해서 Runner명시적으로 지정 @Suiteclasses(Class[]) 여러개의 테스트 클래스를 수행하기 위해서 쓰임 @RunWith(Suite.class)@SuiteClass(Class[]) @파라미터를 이용한 테스트 단언문 Hamcrest assertThat(테스트 대상, matcher 구문); assertThat(\u0026ldquo;메시지\u0026rdquo;,테스트대상, matcher 구문); assertEquals(100, accout.getBalance()) assertThat(account.getBalance(), is(equalTo(1000))); assertNotNull(resource.newConnection()); assertThat(resource.newConnection(), is(notNullValue()); assertTrue(account.getBalance() \u0026gt; 0); assertThat(account.getBalance(), isGreaterThan(0)); assertTrue(user.getLoginName().indexOf(\u0026#34;Guest\u0026#34;) \u0026gt; -1)); assertThat(user.getLoginName(), containsString(\u0026#34;Guest\u0026#34;)); is equalsTo greaterThan 대표적인 Matchers1 core anything describdedAs is object equalTo hasToString instanceOf, isCompatibleType notNullValue, nullValue sameInstance logical allOf anyOf not beans hasProperty collection number closedTo greaterThen, greaterThanOrEqualTo, lessThen, lessThenOrEqualTo text equalToIgnoringCase equalToIgnoringWhiteSpace containsString, endsWith, startsWith https://www.lesstif.com/pages/viewpage.action?pageId=18219426\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"/post/java/java-junit/","summary":"java-junit link 용어정리 JUnit 기본 단언문 특징 단언문 Hamcrest 대표적인 Matchers Index\nRelated:\njava-junit sitename test\nlink github-team-junit 용어정리 test context 테스트의 정의 반복적으로 수행되고 동일한 결과를 얻어야 함 테스트케이스에서 사용하는 인스턴스 파일이나 네트워크 등의 자원을 만들어서 지정 데이터베이스 연동 JUnit 기본 단언문 assertEqual: 두개의 값이 같은지 비교 assertSame: 두 개의 객체가 정말 동일한 객체인지 확인 assertTrue: 예상 값의 참 거짓을 판별 asserNull: 대상 값이 null이면 참이 됨 fail 특징 fixture @BeforeClass @AfterClass @Before @After 테스트 종류 시간 제한 테스트 @Test(timeout=1000) 테스트 무시 @Ignore 배열지원 @RunWith JUnit Test 클래스를 실행하기 위해서 Runner명시적으로 지정 @Suiteclasses(Class[]) 여러개의 테스트 클래스를 수행하기 위해서 쓰임 @RunWith(Suite.","title":"java-junit"},{"content":"spring application context에 대해서 이야기 합니다.\n","permalink":"/dev/spring/spring-application-context/","summary":"spring application context에 대해서 이야기 합니다.","title":"Application Context"},{"content":"chap1 자동으로 backlink가 포함되서 다음과 같이 일을 정리해볼 수 있습니다. 이렇게 포함된 노트를 바탕으로 쉽게 글을 쓸 수 있구요.\n오호 요기에 바로 옮겨 쓸수도 있습니다. 다음과 같이 글을 쓸수 도 있쬬\nchap2 2021-04-28에 다음과 같은 링크를 쓸 수 있습니다. ㅇ리ㅓㅁㄴㅇ리ㅑ머니ㅑ얼ㅁㄴ디ㅑ러ㅣㅑㅓㅁ니댜러미냐더리먀너디ㅑ러미냐더리ㅑㅓㅐ\nasldifjalsidjf alsiejflisaj ","permalink":"/post/20210428010112-docker/","summary":"chap1 자동으로 backlink가 포함되서 다음과 같이 일을 정리해볼 수 있습니다. 이렇게 포함된 노트를 바탕으로 쉽게 글을 쓸 수 있구요.\n오호 요기에 바로 옮겨 쓸수도 있습니다. 다음과 같이 글을 쓸수 도 있쬬\nchap2 2021-04-28에 다음과 같은 링크를 쓸 수 있습니다. ㅇ리ㅓㅁㄴㅇ리ㅑ머니ㅑ얼ㅁㄴ디ㅑ러ㅣㅑㅓㅁ니댜러미냐더리먀너디ㅑ러미냐더리ㅑㅓㅐ\nasldifjalsidjf alsiejflisaj ","title":"docker"},{"content":" 아래와 같이 설정해주면 inline 이미지에서 스크롤시 점프하지 않는다. ;; https://emacs.stackexchange.com/questions/10354/smooth-mouse-scroll-for-inline-images (pixel-scroll-mode) (setq pixel-dead-time 0) ; Never go back to the old scrolling behaviour. (setq pixel-resolution-fine-flag t) ; Scroll by number of pixels instead of lines (t = frame-char-height pixels). (setq mouse-wheel-scroll-amount \u0026#39;(1)) ; Distance in pixel-resolution to scroll each mouse wheel event. (setq mouse-wheel-progressive-speed nil) ; Progressive speed is too fast for me. ","permalink":"/post/emacs/emacs-scroll-pixel/","summary":" 아래와 같이 설정해주면 inline 이미지에서 스크롤시 점프하지 않는다. ;; https://emacs.stackexchange.com/questions/10354/smooth-mouse-scroll-for-inline-images (pixel-scroll-mode) (setq pixel-dead-time 0) ; Never go back to the old scrolling behaviour. (setq pixel-resolution-fine-flag t) ; Scroll by number of pixels instead of lines (t = frame-char-height pixels). (setq mouse-wheel-scroll-amount \u0026#39;(1)) ; Distance in pixel-resolution to scroll each mouse wheel event. (setq mouse-wheel-progressive-speed nil) ; Progressive speed is too fast for me. ","title":"emacs 스크롤을 pixcel 단위로 변경하기"},{"content":"설치 brew install hugo 디렉토리 구조 만들기 hugo new site {blog_name} theme추가 git submodule add https://github.com/budparr/gohugo-theme-ananke.git themes/ananke git submodule add -b master https://github.com/karohani/karohani.github.com public google에서 사이트가 검색 되도록 하기 Google Search Console에 SiteMap등록 google webmaster 파일을 다운 받은 뒤에 static폴더 안에 넣고 검증 버튼을 누르면 완료된다. OX-hugo를 이용해서 실제 데이터와 바인딩하기 주의점 파일 이름이 한글이면 제대로 출력되지 않는다. TITLE은 한글로 하더라도 파일이름은 한글로 해서는 안된다 ㅠㅠ 젠장 ","permalink":"/post/essay/how-to-make-static-blog-by-using-hugo/","summary":"설치 brew install hugo 디렉토리 구조 만들기 hugo new site {blog_name} theme추가 git submodule add https://github.com/budparr/gohugo-theme-ananke.git themes/ananke git submodule add -b master https://github.com/karohani/karohani.github.com public google에서 사이트가 검색 되도록 하기 Google Search Console에 SiteMap등록 google webmaster 파일을 다운 받은 뒤에 static폴더 안에 넣고 검증 버튼을 누르면 완료된다. OX-hugo를 이용해서 실제 데이터와 바인딩하기 주의점 파일 이름이 한글이면 제대로 출력되지 않는다. TITLE은 한글로 하더라도 파일이름은 한글로 해서는 안된다 ㅠㅠ 젠장 ","title":"hugo를 사용한 정적 블로깅"},{"content":"설치 brew install hugo 디렉토리 구조 만들기 hugo new site {blog_name} theme추가 git submodule add https://github.com/budparr/gohugo-theme-ananke.git themes/ananke git submodule add -b master https://github.com/karohani/karohani.github.com public google에서 사이트가 검색 되도록 하기 Google Search Console에 SiteMap등록 google webmaster 파일을 다운 받은 뒤에 static폴더 안에 넣고 검증 버튼을 누르면 완료된다. ","permalink":"/post/hugo%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%B4%EC%84%9C-%EC%A0%95%EC%A0%81%EB%B8%94%EB%A1%9C%EA%B9%85%ED%95%98%EA%B8%B0/","summary":"설치 brew install hugo 디렉토리 구조 만들기 hugo new site {blog_name} theme추가 git submodule add https://github.com/budparr/gohugo-theme-ananke.git themes/ananke git submodule add -b master https://github.com/karohani/karohani.github.com public google에서 사이트가 검색 되도록 하기 Google Search Console에 SiteMap등록 google webmaster 파일을 다운 받은 뒤에 static폴더 안에 넣고 검증 버튼을 누르면 완료된다. ","title":"hugo를 사용한 정적 블로깅"},{"content":"MySQL to_base64 함수는 개행을 추가한다. 아래의 동작을 기본으로 하기 때문에 주의! JSON String을 암호화 하고 복호화 할 때 이슈가 발생한다. https://dev.mysql.com/doc/refman/8.0/en/string-functions.html\n","permalink":"/post/mysql/mysql_troubleshooting/","summary":"MySQL to_base64 함수는 개행을 추가한다. 아래의 동작을 기본으로 하기 때문에 주의! JSON String을 암호화 하고 복호화 할 때 이슈가 발생한다. https://dev.mysql.com/doc/refman/8.0/en/string-functions.html","title":"mysql-troubleshooting"},{"content":"생각을 기록하면 이렇게 된다 최고의 모드는 orgmode이다.\n하지만 최대한 다른 모드와 기능들은 배제하고 내가 직접 작성한 것들만 사용하고 싶다. 그러면 역시 orgmode와 이것을 조합한게 최고인듯? \u0026lt;201022-1143-zettelkasten.org\u0026gt;\n핵심 원리 언제든지 찾을 수 있는 unique-id system backlink를 통한 생각의 정리와 조합 카드에는 하나의 아이디어만 있어야 함 (원자성) 각각의 카드를 다른 아이디어와 링크시키기 Reference 뉴스 기사 dpitt.me Using Emacs\u0026rsquo;s org-mode As Your Zettelkasten Org-mode Workflow Part 3: Zettelkasten with Org-mode · Jethro Kuan ","permalink":"/post/essay/201022-1143-zettelkasten/","summary":"생각을 기록하면 이렇게 된다 최고의 모드는 orgmode이다.\n하지만 최대한 다른 모드와 기능들은 배제하고 내가 직접 작성한 것들만 사용하고 싶다. 그러면 역시 orgmode와 이것을 조합한게 최고인듯? \u0026lt;201022-1143-zettelkasten.org\u0026gt;\n핵심 원리 언제든지 찾을 수 있는 unique-id system backlink를 통한 생각의 정리와 조합 카드에는 하나의 아이디어만 있어야 함 (원자성) 각각의 카드를 다른 아이디어와 링크시키기 Reference 뉴스 기사 dpitt.me Using Emacs\u0026rsquo;s org-mode As Your Zettelkasten Org-mode Workflow Part 3: Zettelkasten with Org-mode · Jethro Kuan ","title":"Zettelkasten(상자방법)을 이용한 효과적인 공부방법"},{"content":"엔지니어는 실패를 막는 사람이다. [2021-07-24 Sat 21:17] https://www.youtube.com/watch?v=fHyTA-UIcqs\n","permalink":"/post/etc/20210724211747-%EA%B0%9C%EB%B0%9C%EC%9E%90%EA%B0%80-%EA%B0%96%EC%B6%94%EC%96%B4%EC%95%BC-%ED%95%A0-9%EA%B0%80%EC%A7%80-%EA%B8%B0%EC%88%A0%EC%97%90%EC%84%9C.../","summary":"엔지니어는 실패를 막는 사람이다. [2021-07-24 Sat 21:17] https://www.youtube.com/watch?v=fHyTA-UIcqs","title":"개발자가 갖추어야 할 9가지 기술 - 박종천 넥슨 부본부장"},{"content":"엔지니어링의 깊은 곳 [2021-08-11 Wed 21:45]\n추상화라는 것은 대상의 가지고 있는 것중에 일부분만 투영하는 것\n협력과 계약\n대부분의 코드는 다른 코드와 협력 협력에 필요한 것은 어떻게가 아니라 무엇이다. 누가 담당해서 어떤 과정을 통해서 처리하는 것은 우리에게 중요한 문제가 아니다. 인터페이스 무엇을 표현한다. 협력하는 코드사이의 계약 추상화의 결과이다. 우리는 인터페이스를 대상으로 프로그래밍을 한다. 내용을 고려하지 않는다. print가 어떤 과정을 통해서 이루어지는지는 고려사항이 아니다.\n","permalink":"/post/lecture-note/20210811214554-%ED%98%84%EC%8B%A4%EC%84%B8%EC%83%81%EC%9D%98-tdd-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%A3%BC%EB%8F%84-%EA%B0%9C%EB%B0%9C%EC%9D%98-%EA%B9%8A%EC%9D%80%EA%B3%B3-%EC%9D%B4%EA%B7%9C%EC%9B%90/","summary":"엔지니어링의 깊은 곳 [2021-08-11 Wed 21:45]\n추상화라는 것은 대상의 가지고 있는 것중에 일부분만 투영하는 것\n협력과 계약\n대부분의 코드는 다른 코드와 협력 협력에 필요한 것은 어떻게가 아니라 무엇이다. 누가 담당해서 어떤 과정을 통해서 처리하는 것은 우리에게 중요한 문제가 아니다. 인터페이스 무엇을 표현한다. 협력하는 코드사이의 계약 추상화의 결과이다. 우리는 인터페이스를 대상으로 프로그래밍을 한다. 내용을 고려하지 않는다. print가 어떤 과정을 통해서 이루어지는지는 고려사항이 아니다.","title":"이규원 현실 세상의 TDD 후기"},{"content":"책장 정리 방법1 기계인간님의 정리 방법을 참고로 했다. 3 3 3 1 - 1 1 - 2 MRU - 3 - 3 버릴책 어딘가에서 꺼내서 읽은 책은 MRU 제일 왼쪽에 꽂는다. MRU가 다 차면 이동한다. 다시 사용할 것 같은 책은 2로 이동한다(주로 글쓰기) 버릴 책의 공간이 전부 차면 \u0026ldquo;중고\u0026quot;로 판매하던 없앤다. 1영역은 아직 읽지 않은 책들을 넣어둔다. 다 읽은 책은 아래에서 또는 위에서 찾으면 된다. 안 읽은 책은 [1]을 찾으면 된다. 책 인덱싱 하는 방법 책 어딘가를 찾아 봤다면 포스트잇 플래그에 날짜를 붙여둔다. 자잘한 소도구들 관리방법 매번 박스를 사서 관리하는 것은 어렵다\n박스에 들어가지 않는 작은 케이블들과 물건들은 어떻게 관리하나?\n위에 태그를 붙인 지퍼팩을 활용한다.\n최근에 활용했다면 최근 박스의 가장 앞에 둔다.\n박스가 다 차면 tag에 붙어 있는 날짜를 기준으로 정렬하는 창고로 이동한다.\n창고는 주기적으로 정리한다.\n창고가 다 차면 가장 오래된 것부터 절반을 폐기한다.\n: https://johngrib.github.io/wiki/my-bookshelf/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"/post/life_hacking/%EC%A0%95%EB%A6%AC_%EB%B0%A9%EB%B2%95/","summary":"책장 정리 방법1 기계인간님의 정리 방법을 참고로 했다. 3 3 3 1 - 1 1 - 2 MRU - 3 - 3 버릴책 어딘가에서 꺼내서 읽은 책은 MRU 제일 왼쪽에 꽂는다. MRU가 다 차면 이동한다. 다시 사용할 것 같은 책은 2로 이동한다(주로 글쓰기) 버릴 책의 공간이 전부 차면 \u0026ldquo;중고\u0026quot;로 판매하던 없앤다. 1영역은 아직 읽지 않은 책들을 넣어둔다. 다 읽은 책은 아래에서 또는 위에서 찾으면 된다. 안 읽은 책은 [1]을 찾으면 된다.","title":"정리 방법"}]